"""
Output and notification module
Copyright (c) 2025 Erik Bitzek
Licensed under GNU AGPL v3

This module handles formatting and outputting the daily digest
to text files or email.
"""

import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from typing import List, Dict, Optional


class DigestNotifier:
    """Formats and outputs the daily arXiv digest."""
    
    def __init__(self, output_format: str = 'text', 
                 output_file: str = 'daily_digest.txt',
                 include_abstract: bool = False):
        """
        Initialize the notifier.
        
        Args:
            output_format: 'text', 'email', or 'both'
            output_file: Path for text output
            include_abstract: Whether to include full abstracts
        """
        self.output_format = output_format
        self.output_file = output_file
        self.include_abstract = include_abstract
    
    def format_digest(self, papers: List[Dict], date: Optional[datetime] = None) -> str:
        """
        Format papers into a readable digest.
        
        Args:
            papers: List of paper dictionaries with summaries
            date: Date for the digest (defaults to today)
            
        Returns:
            Formatted digest as string
        """
        if date is None:
            date = datetime.now()
        
        # Build header
        lines = [
            "=" * 80,
            f"arXiv Daily Digest - {date.strftime('%Y-%m-%d')}",
            "=" * 80,
            "",
            f"Found {len(papers)} papers matching your criteria",
            ""
        ]
        
        # Add each paper
        for i, paper in enumerate(papers, 1):
            lines.extend(self._format_paper(paper, i))
            lines.append("")  # Blank line between papers
        
        # Footer
        lines.extend([
            "=" * 80,
            "Generated by arXiv Daily Digest",
            "https://github.com/biterik/arxiv-daily-digest",
            "=" * 80
        ])
        
        return "\n".join(lines)
    
    def _format_paper(self, paper: Dict, number: int) -> List[str]:
        """Format a single paper entry."""
        lines = [
            f"[{number}] {paper['title']}",
            "-" * 80
        ]
        
        # Authors
        authors_str = ", ".join(paper['authors'][:5])
        if len(paper['authors']) > 5:
            authors_str += f" (and {len(paper['authors']) - 5} more)"
        lines.append(f"Authors: {authors_str}")
        
        # Dates
        lines.append(f"Published: {paper['published'].strftime('%Y-%m-%d %H:%M UTC')}")
        
        # URLs
        lines.append(f"arXiv: {paper['arxiv_url']}")
        if paper['pdf_url']:
            lines.append(f"PDF: {paper['pdf_url']}")
        
        lines.append("")
        
        # AI Summary
        if 'summary' in paper and paper['summary']:
            lines.append("AI Summary:")
            lines.append(paper['summary'])
            lines.append("")
        
        # Optional: Full abstract
        if self.include_abstract:
            lines.append("Abstract:")
            # Wrap abstract text
            abstract_lines = self._wrap_text(paper['abstract'], 78)
            lines.extend(abstract_lines)
        
        return lines
    
    def _wrap_text(self, text: str, width: int) -> List[str]:
        """Simple text wrapping."""
        words = text.split()
        lines = []
        current_line = []
        current_length = 0
        
        for word in words:
            if current_length + len(word) + 1 <= width:
                current_line.append(word)
                current_length += len(word) + 1
            else:
                if current_line:
                    lines.append(" ".join(current_line))
                current_line = [word]
                current_length = len(word)
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines
    
    def save_to_file(self, content: str) -> None:
        """
        Save digest to text file.
        
        Args:
            content: Formatted digest content
        """
        try:
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(content)
            print(f"\nDigest saved to: {self.output_file}")
        except Exception as e:
            print(f"Error saving to file: {e}")
    
    def send_email(self, content: str, recipient: str, 
                   subject: Optional[str] = None) -> bool:
        """
        Send digest via email.
        
        Args:
            content: Formatted digest content
            recipient: Email address to send to
            subject: Email subject (auto-generated if None)
            
        Returns:
            True if successful, False otherwise
        """
        # Get email credentials from environment
        smtp_server = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
        smtp_port = int(os.getenv('SMTP_PORT', '587'))
        smtp_user = os.getenv('SMTP_USER')
        smtp_password = os.getenv('SMTP_PASSWORD')
        
        print("\n" + "="*80)
        print("EMAIL DEBUG INFORMATION")
        print("="*80)
        print(f"SMTP Server: {smtp_server}")
        print(f"SMTP Port: {smtp_port}")
        print(f"SMTP User: {smtp_user}")
        print(f"SMTP Password set: {'Yes' if smtp_password else 'No'}")
        print(f"Recipient: {recipient}")
        print(f"Content length: {len(content)} characters")
        print("="*80 + "\n")
        
        if not smtp_user or not smtp_password:
            print("❌ Error: SMTP_USER and SMTP_PASSWORD environment variables not set")
            print("\nTo fix this, run:")
            print('  export SMTP_USER="your.email@gmail.com"')
            print('  export SMTP_PASSWORD="your-app-password"')
            return False
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = smtp_user
        msg['To'] = recipient
        msg['Subject'] = subject or f"arXiv Daily Digest - {datetime.now().strftime('%Y-%m-%d')}"
        
        msg.attach(MIMEText(content, 'plain'))
        
        print("Attempting to send email...")
        print(f"  From: {smtp_user}")
        print(f"  To: {recipient}")
        print(f"  Subject: {msg['Subject']}\n")
        
        # Send email
        try:
            print(f"Connecting to {smtp_server}:{smtp_port}...")
            server = smtplib.SMTP(smtp_server, smtp_port, timeout=30)
            server.set_debuglevel(1)  # Enable verbose SMTP debugging
            
            print("Starting TLS...")
            server.starttls()
            
            print(f"Logging in as {smtp_user}...")
            server.login(smtp_user, smtp_password)
            
            print("Sending message...")
            server.send_message(msg)
            
            print("Closing connection...")
            server.quit()
            
            print(f"\n✅ SUCCESS: Digest sent to {recipient}")
            return True
            
        except smtplib.SMTPAuthenticationError as e:
            print(f"\n❌ AUTHENTICATION ERROR:")
            print(f"   {e}")
            print("\nPossible fixes:")
            print("  - For Gmail: Use an App Password, not your regular password")
            print("  - Enable 2-Factor Authentication first")
            print("  - Generate App Password at: https://myaccount.google.com/apppasswords")
            return False
            
        except smtplib.SMTPException as e:
            print(f"\n❌ SMTP ERROR:")
            print(f"   {e}")
            print("\nPossible fixes:")
            print("  - Check SMTP_SERVER and SMTP_PORT are correct")
            print("  - Verify your email provider allows SMTP access")
            return False
            
        except Exception as e:
            print(f"\n❌ UNEXPECTED ERROR:")
            print(f"   Type: {type(e).__name__}")
            print(f"   Message: {e}")
            import traceback
            print("\nFull traceback:")
            traceback.print_exc()
            return False
    
    def output_digest(self, papers: List[Dict], 
                     email_recipient: Optional[str] = None) -> None:
        """
        Output digest according to configured format.
        
        Args:
            papers: List of paper dictionaries with summaries
            email_recipient: Email address (required if format includes email)
        """
        content = self.format_digest(papers)
        
        if self.output_format in ['text', 'both']:
            self.save_to_file(content)
        
        if self.output_format in ['email', 'both']:
            if email_recipient:
                self.send_email(content, email_recipient)
            else:
                print("Warning: Email format requested but no recipient provided")


def test_notifier():
    """Test function to demonstrate usage."""
    # Sample papers
    sample_papers = [
        {
            'title': 'Machine Learning Potentials for Materials',
            'authors': ['Smith, J.', 'Doe, A.'],
            'published': datetime.now(),
            'arxiv_url': 'http://arxiv.org/abs/2401.12345',
            'pdf_url': 'http://arxiv.org/pdf/2401.12345',
            'abstract': 'We develop novel ML potentials...',
            'summary': 'This paper presents a new approach to ML potentials that achieves quantum accuracy at classical cost.'
        }
    ]
    
    notifier = DigestNotifier(output_format='text', output_file='test_digest.txt')
    notifier.output_digest(sample_papers)


if __name__ == "__main__":
    test_notifier()